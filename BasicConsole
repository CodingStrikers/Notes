var x=5;
console.log("value of x is = " +x+" and of y is = "+y);
var x,y=7;
console.log(x);

OUTPUT
value of x is = 5 and of y is = undefined
5

var x=5;
console.log("value of x is = " +x+" and of y is = "+y);
var x=7,y=7;
console.log(x);

OUTPUT
value of x is = 7 and of y is = undefined
5

No are considered as numbers even u mark it in quotes. (string)
console.log("">"2");  False
console.log("3">"2"); True
console.log(3>2);     True

var a=["Vishnu","Kashish","Karan"];
console.log(typeof(a));  // Object

var b=function sa(){}
console.log(typeof(b));  // function

var g=new Date();
console.log(g);
console.log(typeof(g));  // Object


var person={
  firstname:"Vishnu",
  Lastname:"Mehta",
  fullname:function(){
    return this.firstname}
}
console.log(typeof(person.fullname())) //string
console.log(typeof(person.fullname)) //function
console.log(person.fullname()); //Vishnu

function Book(name,year){
  this.name = name;
  this.year = year; 
};
var firstBook=new Book("Vishnu",1997);
console.log(firstBook);


var a=[{FirstName:"Vishnu",LastName:"Mehta"}];
It is an array of Object.
console.log(a.FirstName);  //undefined
console.log(a[0].FirstName); // Vishnu

var a=["Mango","Apple","Grapes"];
var k=a.forEach(Name=>{
  return ("I love to eat "+ Name);})

 var g=a.map(name=>{
  return ("this is my "+name)})

console.log(g);  //
[
"this is my Mango",
"this is my Apple",
"this is my Grapes"
]

console.log(k);  // Output of this will be undefined as forEach doesnt return anything while that of Map returns an array.
console.log(3/"bob");NaN stands for "not a number" and is returned when a mathematical operation cannot 
yield a numeric result.

typeof(NaN) Number

Javascript itself try to convert a string into number if their is any mathematical operator but if their is String inside the 
double quotes it will give NaN.

Eg 3 * "bob";

In JavaScript, undefined, NaN, null, 0, "", and the keyword false are all false in a boolean context. All other values 
are truthy.

var lambchop = function () {
  "This is the song that never ends";
}
console.log(lambchop());
undefined
This is a bit of a trick question. The lambchop() function does not have a return statement, so nothing is 
returned. When a function do not specify any return value, undefined is returned by default.

Function by default returns undefined if the function is not returning anything.
function add(x, y) {
  return(x + y);
}
console.log(add(1, 2, 3, 4, 10, 20));
3
The add() function takes two arguments, but was supplied with 6 arguments when it was invoked. When functions are 
called with extra arguments, an error is not thrown and JavaScript simply ignores the extra arguments.

function lamp() {
  var my_special_variable = "I am special";
}
lamp();
console.log(my_special_variable);
ReferenceError: my_special_variable is not defined
This example throws an exception because my_special_variable is only accessible within the lamp() function. 
In other words, my_special_variable can be used anywhere inside the lamp() function, but cannot be used outside
the lamp() function.


function book() {
  good_book = "Slaughterhouse Five";
}
book();
console.log(good_book);
"Slaughterhouse Five"
The var keyword is not used when the good_book variable is defined, so the good_book variable has global scope 
(it can be used anywhere in the program). Global variables are evil so make sure to always use the var keyword 
when defining variables.

var yao = {
  self: function () { return this }
}
console.log(yao === yao.self());
true
The "this" keyword is available throughout the object and refers to the object itself. this is similar to the concept of 
self in object oriented programming languages. In this contrived example, the self() method returns this, which is the
same as the yao object.

ar game = { title: "tic tac toe" };
var same_game = { title: "tic tac toe" };
console.log(game === same_game );
false
The game and same_game objects have the same contents, but they are different objects. JavaScript only considers 
two objects equal if the equality operator is referring to exactly the same object, not two different objects that 
have the same contents.

function Hat() {
  var brand = "shhh can't tell";
  this.Brand = function () { return brand; };
}
var my_hat = new Hat();
console.log(my_hat.brand);
// Output is Undefined


function Hats() {
  var brand = "shhh can't tell";
  this.Brand = function () { return brand; };
}
var my_hat = new Hats();
console.log(my_hat.Brand());

console.log((function (x, y) { return x + y })(3, 4));  //Output is 7

function a(){
  return this;}
console.log(a());    // [object Window]


var ab={
  g:function aa(){
    if(this==ab)
    {
      return true;
    }}}
 console.log(ab.g());  // true
 
 function blabbermouth() { };
console.log(blabbermouth.name);
.name is the property of the function which displays its name.

U cannot return a variable before it is defined if u do so then it will give a reference error
blah = function () {
  return lala;
  lala = "hi";
};
console.log(blah());

  result = 0;
  arguments.forEach(function (num) {
    result += num;
  });
  return result;
}
sum(1, 2, 3);
This code raises an error because arguments is an array-like object, but it's not actually an array, so we can't use 
the forEach() method. According to Douglas Crockford, having arguments as an array-like object and not an actual 
array is a design flaw in the language.

This will clear the doubt why u get [Object object] thing when u alert the object u receive from node side u first need to 
convert it into a string otherwise u cannot display it.

const a={
  name:"Vishnu",
  age:23
}
console.log(a);
console.log(typeof(a));

{name:"Vishnu",age:23}
object

console.log(JSON.stringify(a));
console.log(typeof(JSON.stringify(a)));

{"name":"Vishnu","age":23}
string
